### JPA에서 가장 중요한 2가지

- 객체와 관계형 데이터베이스 매핑하기 (Object Relational Mapping) - 정적 설계
- 영속성 컨텍스트 (jpa가 내부에서 어떻게 동작해?)

#### 영속성 컨텍스트
    - "엔티티를 영구 저장하는 환경" 
        + EntityManager.persist(entity); // 이는 db에 저장하는것이 아니고 영속석컨텍스트에 저장하는것
        + 영속성 컨텍스트는 논리적인 개념
        + 눈에 보이지 않는다
        + 엔티티 매니저를 통해서 영속성 컨텍스트에 접근 (entityManger 1-1 persistenceContext)
        + 엔티티의 생명주기 : (트렌젝션 종료후 삭제) 
            # 비영속(new,transient) 영속성 컨텍스트와 전혀 관개없는 새로운 상태
            # 영속(manged) 영속성 컨텍스트에 관리되는 상태
            # 준영속(detached) 영속성 컨택스트에 저장되었다가 분리된 상태
            # 삭제(removed) 삭제된 상태
            
            이점 : 중간에 디비사이에 있네요 하나의 레이어가 있네
            내부에 1차캐시가 있어요 : 조회를 하면 디비를 바로 요청하는게 아니고 1차캐시부터 조회 
            
        + 쓰기지연sql저장소 - 모아서 sql을 날림
        + 변경감지 dutychecking - 1차캐시상태를 snapshot을 넣어놓는다  스냅샵과 비교해서 다르면 쓰기지연sql에 변경내용을 넣어놓는다.
        + 영속성 컨텍스트의 변경내용을 데이터베이스에 반영  -commit되면 발생 
            - 변경 감지(dirty checking)
            - 수정된 엔티티 쓰기지연sql저장소에 등록
            - 쓰기지연sql
        + 플러시(flush) 
            - em.flush() - 직접호출
            - 트랜젝션 커밋 - 플러시 자동 호출
            - JPQL 쿼리 실행 - 플러시 자동 호출 (원치않다면 Flush.COMMIT하면 되지만 권장하지 않는다)
            - 쓰지지연sql에 반영된다. 1차캐시가 지워지나요? 아닙니다.
            - 속성 컨텍스트를 비오지 않음
            - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
            - 트랜잭션이라는 작업단위가 중용 -> 커밋직직전에만 동기화 하면
            
            
             
  

